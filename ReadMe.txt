  Внутренние параметры - //Parameters
    int N - текущее число заявок в системе
    int N_post - число заявок, поступивших в систему с начала моделирования
    int N_k - текущее число занятых каналов
    double[] T_osv - ближайшие моменты времени освобождения приборов (массив, размерность K)
    double T - текущее системное время
    double T_post - ближайший момент времени поступления заявки в систему
    double[] T_k - суммарные времена занятости каналов (массив, размерность K)

  Вводимые параметры - //Enter parameters
    public int N_max - число реализаций – максимальное число заявок, поступивших в систему (вводимый параметр)
    public static int K - число каналов (вводимый параметр)
    public int IntensiveIn - интенсивность поступления заявок (вводимый параметр)
    public double IntensiveService - интенсивность обслуживания (вводимый параметр)

  Генерируемые внутренние параметры - //Generated_values
    public double t_osv - длительность обслуживания – длительность интервала между моментами начала обслуживания и освобождения прибора (случайная величина)
    public double t_post - длительность интервала между моментами поступления заявок (случайная величина)
    public double T_pred - момент времени предыдущего события (поступления, освобождения)

  Выходные параметры - // Results
    public double P_pr - вероятность простоя системы – вероятность отсутствия занятых каналов (результирующий показатель)
    public double K_z - коэффициент загрузки системы – среднее число занятых каналов (результирующий показатель)




Фунцкии Form_t_post и Form_t_osv отвечают за генерацию случайных значений t_post и t_osv соответсвенно.
Внутри описаны:
Формула 1 = (-1 * ((double) 1 / IntensiveIn) * Math.log(y));
Формула 2 = (-1 * (1 / IntensiveService) * Math.log(y));
Где y - случайное число в диапазоне от 0 до 1 (min + Math.random() * (max - min))




Условие останова алгоритма вынесено в функцию StoppingCondition
Реализация: return (this.N_post >= this.N_max)



*Все формулы есть в файле Сабониса
Реализация формул расчета результирующих показателей:
P_pr: return (double) this.T_k[0] / this.T;
K_z:  double sum = 0;
        for (int i = 0; i < K; i++) {
            sum += (i + 1) * ((double) this.T_k[i] / this.T);
        }
        return sum;



